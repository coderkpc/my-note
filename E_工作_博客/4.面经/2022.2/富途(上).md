富途证券，港企，社招，3年以下工作经验，前端开发岗位。

#### 1.vue生命周期(生命周期中更新是怎么样的) 

> **beforeCreate -> created**
>
> - 初始化`vue`实例，进行数据观测
>
> **created**
>
> - 完成数据观测，属性与方法的运算，`watch`、`event`事件回调的配置
> - 可调用`methods`中的方法，访问和修改data数据触发响应式渲染`dom`，可通过`computed`和`watch`完成数据计算
> - 此时`vm.$el` 并没有被创建
>
> **created -> beforeMount**
>
> - 判断是否存在`el`选项，若不存在则停止编译，直到调用`vm.$mount(el)`才会继续编译
> - 优先级：`render` > `template` > `outerHTML`
> - `vm.el`获取到的是挂载`DOM`的
>
> **beforeMount**
>
> - 在此阶段可获取到`vm.el`
> - 此阶段`vm.el`虽已完成DOM初始化，但并未挂载在`el`选项上
>
> **beforeMount -> mounted**
>
> - 此阶段`vm.el`完成挂载，`vm.$el`生成的`DOM`替换了`el`选项所对应的`DOM`
>
> **mounted**
>
> - `vm.el`已完成`DOM`的挂载与渲染，此刻打印`vm.$el`，发现之前的挂载点及内容已被替换成新的DOM
>
> **beforeUpdate**
>
> - 更新的数据必须是被渲染在模板上的（`el`、`template`、`rende`r之一）
> - 此时`view`层还未更新
> - 若在`beforeUpdate`中再次修改数据，不会再次触发更新方法
>
> **updated**
>
> - 完成`view`层的更新
> - 若在`updated`中再次修改数据，会再次触发更新方法（`beforeUpdate`、`updated`）
>
> **beforeDestroy**
>
> - 实例被销毁前调用，此时实例属性与方法仍可访问
>
> **destroyed**
>
> - 完全销毁一个实例。可清理它与其它实例的连接，解绑它的全部指令及事件监听器
> - 并不能清除DOM，仅仅销毁实例
>
> **使用场景分析**
>
> | 生命周期      | 描述                                                         |
> | :------------ | :----------------------------------------------------------- |
> | beforeCreate  | 执行时组件实例还未创建，通常用于插件开发中执行一些初始化任务 |
> | created       | 组件初始化完毕，各种数据可以使用，常用于异步数据获取         |
> | beforeMount   | 未执行渲染、更新，dom未创建                                  |
> | mounted       | 初始化结束，dom已创建，可用于获取访问数据和dom元素           |
> | beforeUpdate  | 更新前，可用于获取更新前各种状态                             |
> | updated       | 更新后，所有状态已是最新                                     |
> | beforeDestroy | 销毁前，可用于一些定时器或订阅的取消                         |
> | destroyed     | 组件已销毁，作用同上                                         |
>
> #### 数据请求在created和mouted的区别
>
> ​		  `created`是在组件实例一旦创建完成的时候立刻调用，这时候页面`dom`节点并未生成`mounted`是在页面`dom`节点渲染完毕之后就立刻执行的触发时机上`created`是比`mounted`要更早的两者相同点：都能拿到实例对象的属性和方法讨论这个问题本质就是触发的时机，放在`mounted`请求有可能导致页面闪动（页面`dom`结构已经生成），但如果在页面加载前完成则不会出现此情况建议：放在`create`生命周期当中

#### 2.vue中数据发生改变是怎么让视图发生更新的

>组件对相应的数据进行了修改，会触发setter。setter中会调用当前响应式对象的属性订阅器Dep实例上的方法`dep.notify()`,该方法会遍历`this.subs`通知当前响应式对象的所有Watcher，并调用Watcher的update方法去更新页面

#### 3.vue双向绑定原理

> **首先了解vue中的三个核心类：**
>
> 1. Observer：给对象的属性添加getter和setter，用于**依赖收集**和**派发更新**
> 2. Dep：用于收集当前响应式对象的依赖关系，每个响应式对象都有一个dep实例。dep.subs = [watcher1,watcher2] . 当数据发生变更的时候，会通过dep.notify()通知各个watch
> 3. Watcher：观察者对象，`render watcher,computed watcher,user watcher`
>
> **依赖收集**
>
> 1. initState，对computed属性初始化的时候，会触发computed watcher 依赖收集 
> 2. initState，对监听属性初始化的时候，会触发user watcher 依赖收集（程序员自己配置的watch监听）
> 3. render，会触发 render watcher依赖收集
>
> **派发更新**
>
> Object.defineProperty
>
> 1. 组件对相应的数据进行了修改，会触发setter
> 2. dep.notify()
> 3. 遍历所有subs, 调用每一个watcher中的update方法
>
> 当创建vue实例的时候，vue会遍历data里的属性，利用defineProperty为属性添加setter和getter进行数据劫持，一个收集依赖，一个派发更新。每个组件的实力都会有对应的watcher实例

#### 4.TCP如何确保可靠传输 

> TCP协议保证数据传输可靠性的方式主要有：
>
> **校验和：**
>
> 发送的数据包的二进制相加然后取反，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP将丢弃这个报文段和不确认收到此报文段。 
>
> 
>
> **确认应答+序列号（累计确认+seq）：**
>
> TCP传输时将每个字节的数据都进行了编号，这就是序列号。 
>
> 接收方收到报文就会进行确认应答，也就是发送ACK报文，报文中带有对应的确认序列号，告诉发送方下一次从哪发数据
>
> TCP给发送的每一个包进行编号，接收方对数据包进行排序并且去重，把有序数据传送给应用层。 
>
> ![img](http://cdn.itmirror.top//img1396803-20181128203610985-1973068789.png)
>
> 
>
> **超时重传：**
>
> 发送方发送一部分数据后，都会等待接收方发送的ACK报文，并解析ACK报文，判断数据是否传输成功。
>
>  如果发送方发送完数据后，迟迟没有等到接收方的ACK报文，原因可能有两点：
>
> a、数据在传输过程中由于网络原因等直接全体丢包，**接收方没有接收到**。
>
> b、接收方接收到了响应的数据，但是**发送的ACK报文响应**却由于网络原因**丢包了**。
>
> TCP在解决这个问题的时候引入了**超时重传机制**，简单理解就是发送方在发送完数据后等待一个时间，时间到达没有接收到ACK报文，那么对刚才发送的数据进行重新发送。如果是a原因，收到重发数据便进行ACK应答；如果是b原因，根据序列号去重，直接丢弃重复数据，再发一次ACK应答。最大等待(超时)时间是动态计算的。累计一定重传次数，TCP会人会网络异常，强制关闭连接
>
> 
>
> **流量控制：**
>
> TCP连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP使用的流量控制协议是可变大小的滑动窗口协议。
>
> 接收方有即时窗口（滑动窗口），随ACK报文发送。发送方会定期向接收方发送窗口探测数据段，获取窗口大小。
>
> 
>
> **拥塞控制：**
>
> 当网络拥塞时，减少数据的发送。**流量控制是为了让接收方能来得及接收，而拥塞控制是为了降低整个网络的拥塞程度。**
>
> TCP 主要通过四个算法来进行拥塞控制：**慢开始、拥塞避免、快重传、快恢复。**

#### 5.多线程通信要注意什么

>  这个就算了吧，操作系统这块，我看也看不懂，更别说理解了

#### 6.中间代理修改了公钥，客户端怎么校验这个公钥是否合法？

> 引言：首先了解一下非对称加密。非对称加密就是一对多，我们拥有两个秘钥，一个是公钥，一个是私钥。公钥是公开的，私钥是保密的。用私钥加密的数据，只有对应的公钥才能解密，用公钥加密的数据，只有对应的私钥才能解密。我们可以将公钥公布出去，任何想和我们通信的客户， 都可以使用我们提供的公钥对数据进行加密，这样我们就可以使用私钥进行解密，这样就能保证数据的安全了。随之而来的问题就是题目中的，当公钥在网络中传输中转的时候，被中间代理修改成他自己的私钥，我们如果收到这个公钥并用它去加密数据并发送出去，他就可以用它的私钥去解密我们发送出去的数据。
>
> 中间人攻击：攻击过程如下:
>
> - 客户端发送请求到服务端，请求被中间⼈截获
> - 服务器向客户端发送公钥
> - 中间⼈截获公钥，保留在⾃⼰⼿上。然后⾃⼰⽣成⼀个**伪造的**公钥，发给客户端
> - 客户端收到伪造的公钥后，⽣成加密hash值发给服务器
> - 中间⼈获得加密hash值，⽤⾃⼰的私钥解密获得真秘钥,同时⽣成假的加密hash值，发给服务器
> - 服务器⽤私钥解密获得假密钥,然后加密数据传输给客户端
>
> 所以在客户端校验公钥是否合法是非常有必要的，所以要使用数字证书。使用一种Hash算法对**我的公钥+其他信息(原始信息)**进行加密，比如"网站名、邮箱、用户名、用的哪种hash等等"，生成一个信息摘要，让一个认证中心用它的私钥对我们信息摘要进行加密，形成一个签名。最后将原始信息和签名合在一起就是数字证书了，接收方收到数字证书的时候，先根据原始信息使用同样的Hash算法生成摘要，再用认证中心的公钥对数字证书进行解密，将解密后的摘要和生成的摘要作对比，就知道这个公钥有没有被修改、是否合法。

#### 7.xss/csrf

> ##### **XSS**
>
> ###### （1）概念
>
> XSS 攻击指的是跨站脚本攻击，是一种代码注入攻击。攻击者通过在网站注入恶意脚本，使之在用户的浏览器上运行，从而盗取用户的信息如 cookie 等。
>
> XSS 的本质是因为网站没有对恶意代码进行过滤，与正常的代码混合在一起了，浏览器没有办法分辨哪些脚本是可信的，从而导致了恶意代码的执行。
>
> 攻击者可以通过这种攻击方式可以进行以下操作：
>
> - 获取页面的数据，如DOM、cookie、localStorage；
> - DOS攻击，发送合理请求，占用服务器资源，从而使用户无法访问服务器；
> - 破坏页面结构；
> - 流量劫持（将链接指向某网站）；
>
> ###### （2）攻击类型
>
> XSS 可以分为存储型、反射型和 DOM 型：
>
> - 存储型指的是恶意脚本会存储在目标服务器上，当浏览器请求数据时，脚本从服务器传回并执行。
> - 反射型指的是攻击者诱导用户访问一个带有恶意代码的 URL 后，服务器端接收数据后处理，然后把带有恶意代码的数据发送到浏览器端，浏览器端解析这段带有 XSS 代码的数据后当做脚本执行，最终完成 XSS 攻击。 
> - DOM 型指的通过修改页面的 DOM 节点形成的 XSS。
>
> ###### （3）防御措施如下：
>
> - 可以从浏览器的执行来进行预防，一种是使用纯前端的方式，不用服务器端拼接后返回（不使用服务端渲染）。另一种是对需要插入到 HTML 中的代码做好充分的转义。对于 DOM 型的攻击，主要是前端脚本的不可靠而造成的，对于数据获取渲染和字符串拼接的时候应该对可能出现的恶意代码情况进行判断。
> - 使用 CSP ，CSP 的本质是建立一个白名单，告诉浏览器哪些外部资源可以加载和执行，从而防止恶意代码的注入攻击。
>   - CSP 指的是内容安全策略，它的本质是建立一个白名单，告诉浏览器哪些外部资源可以加载和执行。我们只需要配置规则，如何拦截由浏览器自己来实现。
>   - 通常有两种方式来开启 CSP，一种是设置 HTTP 首部中的 Content-Security-Policy，一种是设置 meta 标签的方式 
>
> - 对一些敏感信息进行保护，比如 cookie 使用 http-only，使得脚本无法获取。也可以使用验证码，避免脚本伪装成用户执行一些操作。
>
> ##### **CSRF**
>
> ###### （1）概念
>
> CSRF 攻击指的是**跨站请求伪造攻击**，攻击者诱导用户进入一个第三方网站，然后该网站向被攻击网站发送跨站请求。如果用户在被攻击网站中保存了登录状态，那么攻击者就可以利用这个登录状态，绕过后台的用户验证，冒充用户向服务器执行一些操作。
>
> CSRF 攻击的本质是利用 cookie 会在同源请求中携带发送给服务器的特点，以此来实现用户的冒充。
>
> ###### （2）攻击类型
>
> 常见的 CSRF 攻击有三种：
>
> - GET 类型的 CSRF 攻击，比如在网站中的一个 img 标签里构建一个请求，当用户打开这个网站的时候就会自动发起提交。
> - POST 类型的 CSRF 攻击，比如构建一个表单，然后隐藏它，当用户进入页面时，自动提交这个表单。
> - 链接类型的 CSRF 攻击，比如在 a 标签的 href 属性里构建一个请求，然后诱导用户去点击。
>
> ###### （3）防御措施：
>
> - **进行同源检测**，服务器根据 http 请求头中 origin 或者 referer 信息来判断请求是否为允许访问的站点，从而对请求进行过滤。
> - **使用 CSRF Token 进行验证**，服务器向用户返回一个随机数 Token ，当网站再次发起请求时，在请求参数中加入服务器端返回的 token ，然后服务器对这个 token 进行验证。
> - **对 Cookie 进行双重验证**，服务器在用户访问网站页面时，向请求域名注入一个Cookie，内容为随机字符串，然后当用户再次向服务器发送请求的时候，从 cookie 中取出这个字符串，添加到 URL 参数中，然后服务器通过对 cookie 中的数据和参数中的数据进行比较，来进行验证。
> - **在设置 cookie 属性的时候设置 Samesite ，限制 cookie 不能作为被第三方使用**，从而可以避免被攻击者利用。

#### 8.图片懒加载/自适应

> 也叫做延迟加载、按需加载，指的是在长网页中延迟加载图片数据，是一种较好的网页性能优化的方式。在比较长的网页或应用中，如果图片很多，所有的图片都被加载出来，而用户只能看到可视窗口的那一部分图片数据，这样就浪费了性能。在滚动屏幕之前，可视化区域之外的图片不会进行加载，在滚动屏幕时才加载。这样使得网页的加载速度更快，减少了服务器的负载。懒加载适用于图片较多，页面列表较长（长列表）的场景中。
>
> 实现原理：图片的加载是由`src`引起的，当对`src`赋值时，浏览器就会请求图片资源。根据这个原理，我们使用HTML5 的`data-xxx`属性来储存图片的路径，在需要加载图片的时候，将`data-xxx`中图片的路径赋值给`src`，这样就实现了图片的按需加载，即懒加载。
>
> **知识点：**
>
> （1）`window.innerHeight` 是浏览器可视区的高度
>
> （2）`document.body.scrollTop || document.documentElement.scrollTop` 是浏览器滚动的过的距离
>
> （3）`imgs.offsetTop` 是元素顶部距离文档顶部的高度（包括滚动条的距离）
>
> （4）图片加载条件：`img.offsetTop < window.innerHeight + document.body.scrollTop;`

#### 9.package-lock.json是做什么用的,它和package.json的区别是什么

> - 记录模块与模块之间的依赖关系
> - 锁定包的版本
> - 记录项目所依赖第三方包的树状结构和包的下载地址，加快重新安装的下载速度
>
> 一句话来概括很简单，就是锁定安装时的包的版本号，并且需要上传到git，以保证其他人在npm install时大家的依赖能保证一致。**package.json文件只能锁定大版本，也就是版本号的第一位，并不能锁定后面的小版本，你每次npm install都是拉取的该大版本下的最新的版本**，为了稳定性考虑我们几乎是不敢随意升级依赖包的，这将导致多出来很多工作量，测试/适配等，所以package-lock.json文件出来了，当你每次安装一个依赖的时候就锁定在你安装的这个版本。

#### 10.dependencies和devDependencies区别是啥

> - dependencies：生产和开发都会用到的依赖，最后会被打包到项目中。
>   - eg：`npm i jquery -S`
>
> - devDependencies ：只在开发环境中使用的依赖，最后不会被打包到项目中。
>   - eg：`npm i webpack -D`

#### 11.讲一下node端怎么解析var a = require('a')，怎么判断a是文件夹还是单个文件的，讲述整个流程

> ![img](http://cdn.itmirror.top//img33ae8ef0-c9ba-11eb-85f6-6fac77c0c9b3.png)
>
> 文件查找的优先级：
>
> - 缓存的模块优先级最高
> - 如果是内置模块，则直接返回，优先级仅次缓存的模块
> - 如果是绝对路径 / 开头，则从根目录找
> - 如果是相对路径 ./开头，则从当前require文件相对位置找
> - 如果文件没有携带后缀，先从js、json、node按顺序查找
> - 如果是目录，则根据 package.json的main属性值决定目录下入口文件，默认情况为 index.js
> - 如果文件为第三方模块，则会引入 node_modules 文件，如果不在当前仓库文件中，则自动从上级递归查找，直到根目录

#### 12.如果用localStorage存储有效期，怎么实现

> ##### 重写 set(存入) 方法：
>
> ```js
> set(key, value, expired) {
>     /*
> 	* set 存储方法
> 	* @ param {String} 	key 键
> 	* @ param {String} 	value 值，
> 	* @ param {String} 	expired 过期时间，以分钟为单位，非必须
> 	*/
>     let source = this.source;
>     source[key] = JSON.stringify(value);
>     if (expired){
>         source[`${key}__expires__`] = Date.now() + 1000*60*expired
>     };
>     return value;
> }
> ```
>
> ###### 重写 get(获取) 方法：
>
> ```js
> get(key) {
>     /*
> 	* get 获取方法
> 	* @ param {String} 	key 键
> 	* @ param {String} 	expired 存储时为非必须字段，所以有可能取不到，默认为 Date.now+1
> 	*/
>     const source = this.source,
>           expired = source[`${key}__expires__`]||Date.now+1;
>     const now = Date.now();
> 
>     if ( now >= expired ) {
>         this.remove(key);
>         return;
>     }
>     const value = source[key] ? JSON.parse(source[key]) : source[key];
>     return value;
> }
> ```
>
> ##### 重写 remove(删除) 方法：
>
> ```js
> remove(key) {
>     const data = this.source,
>           value = data[key];
>     delete data[key];
>     delete data[`${key}__expires__`];
>     return value;
> }
> ```

#### 13.同步和异步

> 太基础了，如果真的要展开说的话，有很多很多可以说的。可以说到单线程+异步模型、主线程+执行栈、浏览器工作线程、宏任务微任务，还可以说回调地狱、ES6的Promise、Generator、ES8的async/await，展开说能说很多很多，过于基础的东西就不在面经里展开讨论了。

#### 14.深度优先遍历和广度优先遍历

> emmmm，算法和数据结构是我的弱项，以后学明白了再更新吧

一共28题，分上下两篇更



