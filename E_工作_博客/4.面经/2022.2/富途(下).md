昨天写完忘记发了...

#### 15.前端鉴权

>1. 使用全局路由守卫
>   - 前端定义好路由，并且在路由上标记相应的权限信息
>   - 全局路由守卫每次都判断用户是否已经登录，没有登录则跳到登录页。
>   - 已经登录 (已经取得后台返回的用户的权限信息(角色之类的))，则判断当前要跳转的路由，用户是否有权限访问
>   - 没有权限则跳到事先定义好的界面 ( 403、404 之类的)。
>   - 缺点：
>     - 加载所有的路由，如果路由很多，而用户并不是所有的路由都有权限访问，对性能会有影响。
>     - 每次路由跳转都要做权限判断。
>     - 菜单跟路由耦合在一起，定义路由的时候还有添加菜单显示标题，图标之类的信息，而且路由不一定作为菜单显示，还要多加字段进行标识。
>2. 登录页与主应用分离
>   - 登录成功后，进行页面跳转
>   - 将用户权限传递到主应用所在页面，主应用初始化之前，根据用户权限筛选路由，筛选后的路由作为 vue 的实例化参数
>   - 不需要在全局路由守卫里做权限判断
>   - 缺点：
>     - 需要做页面跳转，不是纯粹的单页应用。
>     - 菜单信息写死在前端，要改个显示文字或权限信息，需要重新编译。
>     - 菜单跟路由耦合在一起，定义路由的时候还有添加菜单显示标题，图标之类的信息，而且路由不一定作为菜单显示，还要多加字段进行标识。
>3. 使用 addRoutes 动态挂载路由
>   - 应用初始化的时候先挂载不需要权限控制的路由，比如登录页，404 等错误页。
>   - 登录后，获取用户的权限信息，然后筛选有权限访问的路由，再调用 addRoutes 添加路由。
>   -  addRoutes 要在全局路由守卫里进行调用
>   - 缺点：
>     - 全局路由守卫里，每次路由跳转都要做判断
>     - 菜单信息写死在前端，要改个显示文字或权限信息，需要重新编译
>     - 菜单跟路由耦合在一起，定义路由的时候还有添加菜单显示标题，图标之类的信息，而且路由不一定作为菜单显示，还要多加字段进行标识
>4. 菜单与路由分离，菜单由后端返回
>   - 路由全部注册，后端返回一个菜单表，表中要有一个字段和前端的路由表对应，让菜单能根据改字段跳转到路由
>   - 后端根据用户的权限返回菜单表
>   - 缺点：
>     - 前后端配合要好，菜单和路由要一一对应
>5. 还有别的就不一一列举了

#### 16.怎么实现 async await

> 我单独写一篇博客来讲

#### 17.JS 为什么放到后面，CSS会阻塞渲染吗

> 先来看一张图
>
> ![](http://cdn.itmirror.top//img3534846-00ef9f3d405462ef.png)
>
> ​        看完图我们先来讨论css会不会阻塞渲染，首先我们要搞清这个渲染指的是渲染什么？如果说把DOM树的构建称为渲染，那么是不阻塞的，因为从这张图可以看出来，CSS规则树和DOM树是并行构建的。但是一般我们把页面的渲染才叫做渲染，然而DOM树和CSS规则树必须都准备好，才能生成一个叫渲染树的东西，浏览器会根据渲染树对页面进行布局和绘制，所以说如果CSS的文件加载慢，是会阻塞页面的渲染的。CSS会阻塞渲染吗？一开始我说的是不会，因为我把DOM树的构建理解成了渲染，整个流程我是懂的，但是答歪了，后面面试官重新解释了一遍问题，我才说是会阻塞的hhh
>
> js为什么放到后面呢？我们再来看一张图![](http://cdn.itmirror.top//imgimage-20220320202256362.png)
>
> 可以看到js文件的加载会阻塞页面的渲染，浏览器遇到script标签会立即停止渲染页面 开始加载js文件，而我们的js文件中有很多对于dom的操作，比如说事件绑定等等，把js放在前面的话，在执行js脚本的时候DOM元素还没有被创建，我们并不能获取到DOM元素，所以通常来说我们把script标签放在body的最后部分。
>
> 再来说说defer和async属性对于script标签有什么作用？用defer属性，按顺序设置三个script标签，它们就算放前面也不会阻塞页面渲染，而会在页面渲染完按顺序执行js脚本；而async属性，会让script标签加载js文件不阻塞页面渲染，但是加载完会立即执行并阻塞页面渲染，上面这张图可以看出来，如果是好几个用了async属性的script标签，不会按顺序执行，而是谁先加载完谁先执行。

#### 18.说一下Promise，实现一个方法，获取所有promise的结果，以数组形式返回，不论成功或者失败

> Promise也和async await放一块单独开一篇文章讲
>
> 这题考的其实就是手写Promise的allSettled方法，不难，可以参照我的[手写Promise](https://itmirror.top/2022/03/16/22%E5%B9%B42%E6%9C%88%E6%B7%B1%E4%BF%A1%E6%9C%8D+%E6%95%B0%E5%AD%97%E6%94%BF%E9%80%9A/)
>
> ```js
> static allSettled(promises) {
>     //接收一个Promise数组
>     return new Promise((resolve, reject) => {
>         const res = []
>         let count = 0
>         const addData = (status, value, i) => {
>             res[i] = {
>                 status,
>                 value
>             }
>             count++
>             //把每一个Promise的结果，集合成数组，返回
>             if (count === promises.length) {
>                 resolve(res)
>             }
>         }
>         promises.forEach((promise, i) => {
>             if (promise instanceof MyPromise) {
>                 promise.then(res => {
>                     addData('fulfilled', res, i)
>                 }, err => {
>                     addData('rejected', err, i)
>                 })
>             } else {
>                 //数组中如有非Promise项，则此项当做成功
>                 addData('fulfilled', promise, i)
>             }
>         })
>     })
> }
> ```

#### 19.HTTP 请求体的内容

> 请求组成：
>
> - 请求行
> - 请求头部
> - 空行
> - 请求体
>
> 请求体内容就是请求携带的数据，你发请求时传的data，没啥难的

#### 20.写一个10个人抽奖，不能抽重复， 那如果分两组 一组概率 70 一组 30 怎么实现 （ 随机数大于 7 和小于 7）

> 就是一个1到10的数组，用random函数随机splice一个，然后再splice。。。这样防止递归时候random极限情况下一直相同导致爆栈的问题..

#### 21.手写遍历方法

> forEach方法接收两个参数，第一个参数是一个函数，第二个参数是改变this指向的值（很多人都没注意到）。 函数接收三个参数，分别为数组每一项、数组的下标以及数组本身。
>
> 使用示例：
>
> ```js
> let arr = [1, 2, 3];
> arr.forEach((item, index, array) => {
>     //do something
> }, thisArg)
> ```
>
> 手写代码：
>
> ```js
> Array.prototype.myForEach = function (fn) {
>     //看是否传了第二个参数，没传上下文就指向window
>     let context = arguments[1] || window;
> 	//判断传的第一个参数是否为函数，若不是则抛出一个错误
>     if (typeof fn === 'function') {
>         for (let i = 0; i < this.length; i++) {
>             //对数组进行遍历处理，这里使用ES3的call方法调用函数，并指定this指向，依次传入数组项、下标以及数组自身
>             fn.call(context, this[i], i, this)
>         }
>     } else {
>         throw new Error('parameter1 is not a function')
>     }
> }
> ```

#### 22.302 301 永久重定向和临时重定向除了语义的区别还有什么区别， 比如 什么情况下会 301 或 302

> 301：永久重定向很好理解，页面永久的搬家了，浏览器收到这个状态码会看一下用户是否收藏了原来的网址，会自动替换成新的。更换域名的时候会用301状态码，告诉浏览器同时也告诉搜索引擎和用户：网站搬家了。搜索引擎在抓取新内容的同时也将旧的网址替换为重定向之后的网址。
>
> 302：临时重定向也很好理解，用户没登录的时候(没有token或cookie)，不让访问主页面，或者访问了个404，临时定向到首页，或者做活动的时候登陆完临时定向到活动页而不是首页。搜索引擎会抓取重定向后的内容给旧的网址。

#### 23.return continue break的区别

> 在函数体中return后的语句不会执行
>
> continue是跳出当次循环，开始判断下一次循环是否执行
>
> break是跳出最近的循环体，后面的循环都不执行了，可以和label配合跳出层次比较深的循环。
>
> ```js
> label1:
> while (true) {
>     for (int i = 0; i <= 10; i++) {
>         System.out.println("i=" + i);
>         if (i == 5) {
>             break label1;
>         }
>     }
>     System.out.println("++++++++++++++++++++++");
> }
> //它在满足break条件时跳出了label1标记的一个代码块.
> ```

#### 24.foreach什么时候可以跳出循环

> try....catch    抛出异常就可以中断

#### 25.闭包/eventloop/原型链

> 1. 啥是闭包？
>
>    1. 闭包是指有权访问另一个函数作用域中变量的函数
>    2. 都知道闭包不好要少用，也知道闭包的概念和场景，张口就来：缓存、节流和防抖、柯里化。。。
>    3. 其实闭包比我们想的还要常见的多，也用的多：只要你在某个函数中声明了另一个函数，就创建了一个闭包。
>
> 2. 啥是事件轮询？
>
>    1. 首先都知道js是单线程的，但是单线程怎么做那么多事呢：定时器、http请求、GUI渲染、事件触发，所以有了主线程和工作线程的概念。
>
>    2. js在执行的时候，遇到异步代码会交给工作线程挂起，先执行script标签中的所有同步代码，由工作线程去判断异步代码是否可以执行了：http请求返回了、事件触发、定时器触发等等。工作线程会将准备好的任务放进任务队列。
>
>    3. 每当主线程把宏任务的代码都执行完了，事件轮询开始问任务队列：你这里面有微任务吗？有的话，排好队我挨个执行一遍，然后再执行下一个宏任务。所以我们得清楚异步代码什么时候执行并不取决于这个任务什么时候被挂起，而在于工作线程什么时候把这个任务放进任务队列。![在这里插入图片描述](http://cdn.itmirror.top//img2021070213542153.png)
>
>    4. 宏任务
>
>       | #                       | 浏览器 | Node |
>       | ----------------------- | ------ | ---- |
>       | `I/O`                   | ✅      | ✅    |
>       | `setTimeout`            | ✅      | ✅    |
>       | `setInterval`           | ✅      | ✅    |
>       | `setImmediate`          | ❌      | ✅    |
>       | `requestAnimationFrame` | ✅      | ❌    |
>
>    5. 微任务
>
>       | #                            | 浏览器 | Node |
>       | ---------------------------- | ------ | ---- |
>       | `process.nextTick`           | ❌      | ✅    |
>       | `MutationObserver`           | ✅      | ❌    |
>       | `Promise.then catch finally` | ✅      | ✅    |
>
> 3. 啥是原型链？三句话概括
>
>    1. 实例对象的隐式原型(`f1.__proto__`)指向构造函数的显式原型(`Fn.prototype`)
>    2. 构造函数的显式原型(`Fn.prototype`)指向原型对象(`其实也就是个普通对象`)，原型对象的构造器(`Fn.prototype.constructor`)指向构造函数(`Fn`)
>    3. 调用对象的方法和属性的时候，js引擎会顺着对象的`__proto__`属性一层层往上找，这就是原型链。直到原型链的尽头才会停止(`Object.prototype.__proto__ === null // true`)

#### 26.进程与线程的区别

> - 进程可以看做独立应用，线程不能
> - 资源：进程是cpu资源分配的最小单位（是能拥有资源和独立运行的最小单位）；线程是cpu调度的最小单位（线程是建立在进程的基础上的一次程序运行单位，一个进程中可以有多个线程）。
> - 通信方面：线程间可以通过直接共享同一进程中的资源，而进程通信需要借助 进程间通信。
> - 调度：进程切换比线程切换的开销要大。线程是CPU调度的基本单位，线程的切换不会引起进程切换，但某个进程中的线程切换到另一个进程中的线程时，会引起进程切换。
> - 系统开销：由于创建或撤销进程时，系统都要为之分配或回收资源，如内存、I/O 等，其开销远大于创建或撤销线程时的开销。同理，在进行进程切换时，涉及当前执行进程 CPU 环境还有各种各样状态的保存及新调度进程状态的设置，而线程切换时只需保存和设置少量寄存器内容，开销较小。

#### 27.浅拷贝/深拷贝(定义不是手写) 

> 浅拷贝可以用es6的扩展运算符，也可以用Object.assign()。所谓浅拷贝就是浅层的拷贝(废话)？拷贝对象和数组的时候如果某个元素和属性是引用类型的，只会拷贝它的引用地址到新对象/数组上。
>
> 深拷贝就是不管层次有多深，是不是引用类型的属性/元素，都会拷贝出一个一模一样的新的。递归就完事了，那么如何写出一个惊艳面试官的递归？直接上代码：很好懂
>
> ```js
> function deepClone(obj, cache = new WeakMap()) {
>     if (obj === null || typeof obj !== 'object') return obj
>     if (obj instanceof Date) return new Date(obj)
>     if (obj instanceof RegExp) return new RegExp(obj)
> 
>     if (cache.get(obj)) return cache.get(obj) // 如果出现循环引用，则返回缓存的对象，防止递归进入死循环
>     let cloneObj = new obj.constructor() // 使用对象所属的构造函数创建一个新对象
>     cache.set(obj, cloneObj) // 缓存对象，用于循环引用的情况
> 
>     for (let key in obj) {
>         if (obj.hasOwnProperty(key)) {
>             cloneObj[key] = deepClone(obj[key], cache) // 递归拷贝
>         }
>     }
>     return cloneObj
> }
> 
> // 测试
> const obj = { name: 'Jack', address: { x: 100, y: 200 } }
> obj.a = obj // 循环引用
> const newObj = deepClone(obj)
> console.log(newObj.address === obj.address) // false
> ```
>
> 什么？你不懂Weakmap？不知道是啥？能写出来可别让面试官发现你不懂，快去看[阮一峰的ES6](https://es6.ruanyifeng.com/#docs/set-map#WeakMap)

#### 28.如何发布一个npm包 

> 先得配置好你的包：
>
> - package.json的配置如下
> - name代表了你发的包的名字（不能和npm上已存在的包名字相同）
> - version是你发的包的版本号（以后更新包的时候得修改版本号）
> - dependencies是你这个包所依赖的包
>
> 然后npm官网你得有号，记得邮箱认证，在本地终端npm adduser登录
>
> 再然后npm publish --access public

